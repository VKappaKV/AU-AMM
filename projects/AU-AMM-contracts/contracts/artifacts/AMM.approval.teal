#pragma version 10
intcblock 0 1 1000 4 10 16 300_000 3 6
bytecblock 0x 0x61756374696f6e5f7374617465 0x706f6f6c5f746f6b656e 0x61737365745f61 0x61737365745f62 0x706f6f6c5f6d616e61676572 0x626964646572735f6465706f7369745f7265676973747279 0x63757272656e745f666565 0x64656661756c745f6d616e61676572 0x6d61785f666565 0x726174696f 0x151f7c75

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 8 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\AMM.algo.ts:38
	// this.default_manager.value = this.txn.sender
	bytec 8 //  "default_manager"
	txn Sender
	app_global_put

	// contracts\AMM.algo.ts:39
	// this.currentFee.value = 50
	bytec 7 //  "current_fee"
	pushint 50
	app_global_put
	retsub

// bootstrap(pay,uint64,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	bytec 11 // 0x151f7c75

	// maxFee: uint64
	txna ApplicationArgs 3
	btoi

	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// seed: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 3 (seed) for bootstrap must be a pay transaction
	assert

	// execute bootstrap(pay,uint64,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	intc 1 // 1
	return

// bootstrap(seed: PayTxn, aAsset: AssetID, bAsset: AssetID, maxFee: uint64): AssetID
bootstrap:
	proto 4 1

	// contracts\AMM.algo.ts:43
	// this.maxFee.value = maxFee
	bytec 9 //  "max_fee"
	frame_dig -4 // maxFee: uint64
	app_global_put

	// contracts\AMM.algo.ts:44
	// verifyAppCallTxn(this.txn, { sender: this.default_manager.value })
	// verify sender
	txn Sender
	bytec 8 //  "default_manager"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.default_manager.value"}
	assert

	// contracts\AMM.algo.ts:48
	// verifyPayTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // seed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"seed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // seed: PayTxn
	gtxns Amount
	intc 6 // 300_000
	>=

	// transaction verification failed: {"txn":"seed","field":"amount","condition":"greaterThanEqualTo","expected":">=300_000"}
	assert

	// contracts\AMM.algo.ts:49
	// assert(aAsset < bAsset)
	frame_dig -2 // aAsset: AssetID
	frame_dig -3 // bAsset: AssetID
	<
	assert

	// contracts\AMM.algo.ts:51
	// this.assetA.value = aAsset
	bytec 3 //  "asset_a"
	frame_dig -2 // aAsset: AssetID
	app_global_put

	// contracts\AMM.algo.ts:52
	// this.assetB.value = bAsset
	bytec 4 //  "asset_b"
	frame_dig -3 // bAsset: AssetID
	app_global_put

	// contracts\AMM.algo.ts:53
	// this.poolToken.value = this.doCreatePoolToken(aAsset, bAsset)
	bytec 2 //  "pool_token"
	frame_dig -3 // bAsset: AssetID
	frame_dig -2 // aAsset: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\AMM.algo.ts:55
	// this.doOptIn(aAsset, this.app.address)
	global CurrentApplicationAddress
	frame_dig -2 // aAsset: AssetID
	callsub doOptIn

	// contracts\AMM.algo.ts:56
	// this.doOptIn(bAsset, this.app.address)
	global CurrentApplicationAddress
	frame_dig -3 // bAsset: AssetID
	callsub doOptIn

	// contracts\AMM.algo.ts:58
	// return this.poolToken.value;
	bytec 2 //  "pool_token"
	app_global_get
	retsub

// mint(axfer,axfer,uint64,uint64,uint64)void
*abi_route_mint:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// bXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (bXfer) for mint must be a axfer transaction
	assert

	// aXfer: axfer
	txn GroupIndex
	pushint 2
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 4 (aXfer) for mint must be a axfer transaction
	assert

	// execute mint(axfer,axfer,uint64,uint64,uint64)void
	callsub mint
	intc 1 // 1
	return

// mint(aXfer: AssetTransferTxn, bXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
mint:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\AMM.algo.ts:62
	// assert(aAsset === this.assetA.value)
	frame_dig -4 // aAsset: AssetID
	bytec 3 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:63
	// assert(bAsset === this.assetB.value)
	frame_dig -5 // bAsset: AssetID
	bytec 4 //  "asset_b"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:64
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: AssetID
	bytec 2 //  "pool_token"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:66
	// verifyAssetTransferTxn(aXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: aAsset,
	//     })
	// verify sender
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"aXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"aXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"aXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // aAsset: AssetID
	==

	// transaction verification failed: {"txn":"aXfer","field":"xferAsset","expected":"aAsset"}
	assert

	// contracts\AMM.algo.ts:73
	// verifyAssetTransferTxn(bXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: bAsset,
	//     })
	// verify sender
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"bXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"bXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"bXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // bAsset: AssetID
	==

	// transaction verification failed: {"txn":"bXfer","field":"xferAsset","expected":"bAsset"}
	assert

	// *if0_condition
	// contracts\AMM.algo.ts:81
	// this.app.address.assetBalance(aAsset) === aXfer.assetAmount &&
	//       this.app.address.assetBalance(bAsset) === bXfer.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if0_else

	// *if0_consequent
	// contracts\AMM.algo.ts:84
	// this.tokensToMintIntial(aXfer.assetAmount, bXfer.assetAmount)
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToMintIntial
	b *if0_end

*if0_else:
	// contracts\AMM.algo.ts:86
	// toMint = this.tokensToMint(
	//         TOTAL_SUPPLY - this.app.address.assetBalance(poolAsset),
	//         this.app.address.assetBalance(aAsset) - aXfer.assetAmount,
	//         this.app.address.assetBalance(bAsset) - bXfer.assetAmount,
	//         aXfer.assetAmount,
	//         bXfer.assetAmount
	//       )
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	intc 4 // 10
	intc 5 // 16
	exp
	global CurrentApplicationAddress
	frame_dig -3 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	-
	callsub tokensToMint
	frame_bury 0 // toMint: uint64

	// contracts\AMM.algo.ts:94
	// assert(toMint > 0)
	frame_dig 0 // toMint: uint64
	intc 0 // 0
	>
	assert

	// contracts\AMM.algo.ts:96
	// this.doAxfer(this.app.address, this.txn.sender, poolAsset, toMint)
	frame_dig 0 // toMint: uint64
	frame_dig -3 // poolAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

*if0_end:
	retsub

// burn(axfer,uint64,uint64,uint64)void
*abi_route_burn:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// poolXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (poolXfer) for burn must be a axfer transaction
	assert

	// execute burn(axfer,uint64,uint64,uint64)void
	callsub burn
	intc 1 // 1
	return

// burn(poolXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
burn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\AMM.algo.ts:101
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: AssetID
	bytec 2 //  "pool_token"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:102
	// assert(aAsset === this.assetA.value)
	frame_dig -3 // aAsset: AssetID
	bytec 3 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:103
	// assert(bAsset === this.assetB.value)
	frame_dig -4 // bAsset: AssetID
	bytec 4 //  "asset_b"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:105
	// verifyAssetTransferTxn(poolXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//     })
	// verify sender
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"poolXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"poolXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"poolXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: AssetID
	==

	// transaction verification failed: {"txn":"poolXfer","field":"xferAsset","expected":"poolAsset"}
	assert

	// contracts\AMM.algo.ts:112
	// issued = TOTAL_SUPPLY - (this.app.address.assetBalance(poolAsset) - poolXfer.assetAmount)
	intc 4 // 10
	intc 5 // 16
	exp
	global CurrentApplicationAddress
	frame_dig -2 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	-
	frame_bury 0 // issued: uint64

	// contracts\AMM.algo.ts:114
	// aAmt = this.tokensToBurn(issued, this.app.address.assetBalance(aAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -3 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 1 // aAmt: uint64

	// contracts\AMM.algo.ts:116
	// bAmt = this.tokensToBurn(issued, this.app.address.assetBalance(bAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -4 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 2 // bAmt: uint64

	// contracts\AMM.algo.ts:118
	// this.doAxfer(this.app.address, this.txn.sender, aAsset, aAmt)
	frame_dig 1 // aAmt: uint64
	frame_dig -3 // aAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:119
	// this.doAxfer(this.app.address, this.txn.sender, bAsset, bAmt)
	frame_dig 2 // bAmt: uint64
	frame_dig -4 // bAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:121
	// this.ratio.value = this.computeRatio()
	bytec 10 //  "ratio"
	callsub computeRatio
	app_global_put
	retsub

// swap(axfer,uint64,uint64)void
*abi_route_swap:
	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// swapXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 2 (swapXfer) for swap must be a axfer transaction
	assert

	// execute swap(axfer,uint64,uint64)void
	callsub swap
	intc 1 // 1
	return

// swap(swapXfer: AssetTransferTxn, aAsset: AssetID, bAsset: AssetID): void
swap:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\AMM.algo.ts:125
	// assert(aAsset === this.assetA.value)
	frame_dig -2 // aAsset: AssetID
	bytec 3 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:126
	// assert(bAsset === this.assetB.value)
	frame_dig -3 // bAsset: AssetID
	bytec 4 //  "asset_b"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:128
	// verifyAssetTransferTxn(swapXfer, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [aAsset, bAsset] },
	//     })
	// verify assetAmount
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"swapXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"swapXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"swapXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // bAsset: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"swapXfer"},"field":"xferAsset","condition":"includedIn","expected":"[aAsset, bAsset]"}
	assert

	// contracts\AMM.algo.ts:135
	// outId = swapXfer.xferAsset === aAsset ? aAsset : bAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	bz *ternary0_false
	frame_dig -2 // aAsset: AssetID
	b *ternary0_end

*ternary0_false:
	frame_dig -3 // bAsset: AssetID

*ternary0_end:
	frame_bury 0 // outId: uint64

	// contracts\AMM.algo.ts:137
	// inId = swapXfer.xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_bury 1 // inId: uint64

	// contracts\AMM.algo.ts:139
	// fees = this.feeToCollect(swapXfer.assetAmount)
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub feeToCollect
	frame_bury 2 // fees: uint64

	// contracts\AMM.algo.ts:141
	// toSwap = this.tokensToSwap(
	//       swapXfer.assetAmount - fees,
	//       this.app.address.assetBalance(inId) - swapXfer.assetAmount,
	//       this.app.address.assetBalance(outId)
	//     )
	global CurrentApplicationAddress
	frame_dig 0 // outId: uint64
	asset_holding_get AssetBalance
	pop
	global CurrentApplicationAddress
	frame_dig 1 // inId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 2 // fees: uint64
	-
	callsub tokensToSwap
	frame_bury 3 // toSwap: uint64

	// contracts\AMM.algo.ts:147
	// assert(toSwap > 0)
	frame_dig 3 // toSwap: uint64
	intc 0 // 0
	>
	assert

	// contracts\AMM.algo.ts:149
	// this.doAxfer(this.app.address, this.txn.sender, outId, toSwap)
	frame_dig 3 // toSwap: uint64
	frame_dig 0 // outId: uint64
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:151
	// depositTo = this.biddersDepositRegistry(this.poolManager.value).exists
	//       ? this.biddersDepositRegistry(this.poolManager.value).value
	//       : this.poolManager.value
	bytec 6 //  "bidders_deposit_registry"
	bytec 5 //  "pool_manager"
	app_global_get
	concat
	box_len
	swap
	pop
	bz *ternary1_false
	bytec 6 //  "bidders_deposit_registry"
	bytec 5 //  "pool_manager"
	app_global_get
	concat
	box_get

	// box value does not exist: this.biddersDepositRegistry(this.poolManager.value).value
	assert
	b *ternary1_end

*ternary1_false:
	bytec 5 //  "pool_manager"
	app_global_get

*ternary1_end:
	frame_bury 4 // depositTo: address

	// contracts\AMM.algo.ts:155
	// this.doAxfer(this.app.address, depositTo, inId, fees)
	frame_dig 2 // fees: uint64
	frame_dig 1 // inId: uint64
	frame_dig 4 // depositTo: address
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:157
	// this.ratio.value = this.computeRatio()
	bytec 10 //  "ratio"
	callsub computeRatio
	app_global_put
	retsub

// createBidderEscrow(pay)address
*abi_route_createBidderEscrow:
	// The ABI return prefix
	bytec 11 // 0x151f7c75

	// payMBR: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (payMBR) for createBidderEscrow must be a pay transaction
	assert

	// execute createBidderEscrow(pay)address
	callsub createBidderEscrow
	concat
	log
	intc 1 // 1
	return

// createBidderEscrow(payMBR: PayTxn): Address
createBidderEscrow:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\AMM.algo.ts:161
	// verifyPayTxn(payMBR, {
	//       receiver: this.app.address,
	//       amount: { greaterThan: 400_000 },
	//     })
	// verify receiver
	frame_dig -1 // payMBR: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payMBR","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payMBR: PayTxn
	gtxns Amount
	pushint 400_000
	>

	// transaction verification failed: {"txn":"payMBR","field":"amount","condition":"greaterThan","expected":">400_000"}
	assert

	// contracts\AMM.algo.ts:166
	// bidderPuppetAccount = sendMethodCall<typeof PuppetAddress.prototype.new>({
	//       onCompletion: OnCompletion.DeleteApplication,
	//       approvalProgram: PuppetAddress.approvalProgram(),
	//       clearStateProgram: PuppetAddress.clearProgram(),
	//     })
	itxn_begin
	intc 8 //  appl
	itxn_field TypeEnum
	pushbytes 0x561d2fea // method "new()address"
	itxn_field ApplicationArgs

	// contracts\AMM.algo.ts:167
	// onCompletion: OnCompletion.DeleteApplication
	pushint 5 // DeleteApplication
	itxn_field OnCompletion

	// contracts\AMM.algo.ts:168
	// approvalProgram: PuppetAddress.approvalProgram()
	pushbytes 0x0a2002000131181481060b3119088d0c000000000000000000000000000000000000000000000027008004151f7c7588000450b023438a0001b123b210320ab20722b208320eb22022b201b3320a898004561d2fea361a008e01ffcd00
	itxn_field ApprovalProgram

	// contracts\AMM.algo.ts:169
	// clearStateProgram: PuppetAddress.clearProgram()
	pushbytes 0x0a
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // bidderPuppetAccount: address

	// contracts\AMM.algo.ts:172
	// sendPayment({
	//       receiver: bidderPuppetAccount,
	//       amount: 300_000,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:173
	// receiver: bidderPuppetAccount
	frame_dig 0 // bidderPuppetAccount: address
	itxn_field Receiver

	// contracts\AMM.algo.ts:174
	// amount: 300_000
	intc 6 // 300_000
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\AMM.algo.ts:177
	// this.doOptIn(this.poolToken.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 2 //  "pool_token"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:178
	// this.doOptIn(this.assetA.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 3 //  "asset_a"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:179
	// this.doOptIn(this.assetB.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 4 //  "asset_b"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:181
	// this.biddersDepositRegistry(this.txn.sender).value = bidderPuppetAccount
	bytec 6 //  "bidders_deposit_registry"
	txn Sender
	concat
	frame_dig 0 // bidderPuppetAccount: address
	box_put

	// contracts\AMM.algo.ts:183
	// return bidderPuppetAccount;
	frame_dig 0 // bidderPuppetAccount: address

	// set the subroutine return value
	frame_bury 0
	retsub

// bid(uint64,uint64,uint64,uint64,axfer)void
*abi_route_bid:
	// depositTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 0 (depositTxn) for bid must be a axfer transaction
	assert

	// start: uint64
	txna ApplicationArgs 4
	btoi

	// bid: uint64
	txna ApplicationArgs 3
	btoi

	// rounds: uint64
	txna ApplicationArgs 2
	btoi

	// lpAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute bid(uint64,uint64,uint64,uint64,axfer)void
	callsub bid
	intc 1 // 1
	return

// bid(lpAsset: AssetID, rounds: uint64, bid: uint64, start: uint64, depositTxn: AssetTransferTxn): void
bid:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts\AMM.algo.ts:189
	// assert(globals.round + DELAY < start, 'Cannot bid before the 10 round delay from current round')
	global Round
	intc 4 // 10
	+
	frame_dig -4 // start: uint64
	<

	// Cannot bid before the 10 round delay from current round
	assert

	// contracts\AMM.algo.ts:190
	// assert(rounds > 10, 'Rounds must be greater than 10')
	frame_dig -2 // rounds: uint64
	intc 4 // 10
	>

	// Rounds must be greater than 10
	assert

	// contracts\AMM.algo.ts:191
	// assert(bid > 0, 'Bid must be greater than 0')
	frame_dig -3 // bid: uint64
	intc 0 // 0
	>

	// Bid must be greater than 0
	assert

	// contracts\AMM.algo.ts:192
	// assert(lpAsset === this.poolToken.value, 'Invalid LP asset')
	frame_dig -1 // lpAsset: AssetID
	bytec 2 //  "pool_token"
	app_global_get
	==

	// Invalid LP asset
	assert

	// contracts\AMM.algo.ts:194
	// verifyAssetTransferTxn(depositTxn, {
	//       assetReceiver: this.app.address,
	//       xferAsset: this.poolToken.value,
	//       assetAmount: { greaterThan: 0 },
	//     })
	// verify assetReceiver
	frame_dig -5 // depositTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"depositTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -5 // depositTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "pool_token"
	app_global_get
	==

	// transaction verification failed: {"txn":"depositTxn","field":"xferAsset","expected":"this.poolToken.value"}
	assert

	// verify assetAmount
	frame_dig -5 // depositTxn: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"depositTxn","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// contracts\AMM.algo.ts:200
	// totalDeposit = depositTxn.assetAmount
	frame_dig -5 // depositTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_bury 0 // totalDeposit: uint64

	// contracts\AMM.algo.ts:201
	// assert(totalDeposit >= bid * rounds, 'Need to deposit enough to keep the bid for all rounds declared')
	frame_dig 0 // totalDeposit: uint64
	frame_dig -3 // bid: uint64
	frame_dig -2 // rounds: uint64
	*
	>=

	// Need to deposit enough to keep the bid for all rounds declared
	assert

	// contracts\AMM.algo.ts:206
	// bidding: BidObj = {
	//       start: start,
	//       end: start + rounds,
	//       bidder: this.txn.sender,
	//       bid: bid,
	//       deposit: totalDeposit,
	//     }
	frame_dig -4 // start: uint64
	itob
	frame_dig -4 // start: uint64
	frame_dig -2 // rounds: uint64
	+
	itob
	concat
	txn Sender
	concat
	frame_dig -3 // bid: uint64
	itob
	concat
	frame_dig 0 // totalDeposit: uint64
	itob
	concat
	frame_bury 1 // bidding: BidObj

	// *if1_condition
	// contracts\AMM.algo.ts:215
	// state.end < globals.round
	bytec 1 //  "auction_state"
	app_global_get
	extract 8 8
	btoi
	global Round
	<
	bz *if1_end

	// *if1_consequent
	// contracts\AMM.algo.ts:216
	// this.auctionState.value = bidding
	bytec 1 //  "auction_state"
	frame_dig 1 // bidding: BidObj
	app_global_put

	// contracts\AMM.algo.ts:217
	// return;
	retsub

*if1_end:
	// *if2_condition
	// contracts\AMM.algo.ts:219
	// state.start > start
	bytec 1 //  "auction_state"
	app_global_get
	extract 0 8
	btoi
	frame_dig -4 // start: uint64
	>
	bz *if2_end

	// *if2_consequent
	// contracts\AMM.algo.ts:220
	// this.auctionState.value = bidding
	bytec 1 //  "auction_state"
	frame_dig 1 // bidding: BidObj
	app_global_put

	// contracts\AMM.algo.ts:223
	// toRefund = state.deposit - state.bid * (state.end - globals.round)
	bytec 1 //  "auction_state"
	app_global_get
	extract 56 8
	btoi
	bytec 1 //  "auction_state"
	app_global_get
	extract 48 8
	btoi
	bytec 1 //  "auction_state"
	app_global_get
	extract 8 8
	btoi
	global Round
	-
	*
	-
	frame_bury 2 // toRefund: uint64

	// contracts\AMM.algo.ts:224
	// this.doAxfer(this.app.address, state.bidder, lpAsset, toRefund)
	frame_dig 2 // toRefund: uint64
	frame_dig -1 // lpAsset: AssetID
	bytec 1 //  "auction_state"
	app_global_get
	extract 16 32
	global CurrentApplicationAddress
	callsub doAxfer

*if2_end:
	// *if3_condition
	// contracts\AMM.algo.ts:226
	// state.bid < bid
	bytec 1 //  "auction_state"
	app_global_get
	extract 48 8
	btoi
	frame_dig -3 // bid: uint64
	<
	bz *if3_end

	// *if3_consequent
	// contracts\AMM.algo.ts:227
	// this.auctionState.value = bidding
	bytec 1 //  "auction_state"
	frame_dig 1 // bidding: BidObj
	app_global_put

	// contracts\AMM.algo.ts:230
	// toRefund = state.deposit - state.bid * (state.end - globals.round)
	bytec 1 //  "auction_state"
	app_global_get
	extract 56 8
	btoi
	bytec 1 //  "auction_state"
	app_global_get
	extract 48 8
	btoi
	bytec 1 //  "auction_state"
	app_global_get
	extract 8 8
	btoi
	global Round
	-
	*
	-
	frame_bury 3 // toRefund: uint64

	// contracts\AMM.algo.ts:231
	// this.doAxfer(this.app.address, state.bidder, lpAsset, toRefund)
	frame_dig 3 // toRefund: uint64
	frame_dig -1 // lpAsset: AssetID
	bytec 1 //  "auction_state"
	app_global_get
	extract 16 32
	global CurrentApplicationAddress
	callsub doAxfer

*if3_end:
	retsub

// setManager(address)void
*abi_route_setManager:
	// manager: address
	txna ApplicationArgs 1
	dup
	len
	pushint 32
	==

	// argument 0 (manager) for setManager must be a address
	assert

	// execute setManager(address)void
	callsub setManager
	intc 1 // 1
	return

// setManager(manager: Address): void
setManager:
	proto 1 0

	// contracts\AMM.algo.ts:236
	// assert(
	//       manager === this.auctionState.value.bidder && this.auctionState.value.start < globals.round,
	//       'Only the current bidder can be set as manager'
	//     )
	frame_dig -1 // manager: Address
	bytec 1 //  "auction_state"
	app_global_get
	extract 16 32
	==
	dup
	bz *skip_and1
	bytec 1 //  "auction_state"
	app_global_get
	extract 0 8
	btoi
	global Round
	<
	&&

*skip_and1:
	// Only the current bidder can be set as manager
	assert

	// contracts\AMM.algo.ts:240
	// this.poolManager.value = manager
	bytec 5 //  "pool_manager"
	frame_dig -1 // manager: Address
	app_global_put
	retsub

// setNewFee(uint64)void
*abi_route_setNewFee:
	// currentFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute setNewFee(uint64)void
	callsub setNewFee
	intc 1 // 1
	return

// setNewFee(currentFee: uint64): void
setNewFee:
	proto 1 0

	// contracts\AMM.algo.ts:244
	// verifyTxn(this.txn, {
	//       sender: this.poolManager.value,
	//     })
	// verify sender
	txn Sender
	bytec 5 //  "pool_manager"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.poolManager.value"}
	assert

	// contracts\AMM.algo.ts:247
	// assert(currentFee <= this.maxFee.value)
	frame_dig -1 // currentFee: uint64
	bytec 9 //  "max_fee"
	app_global_get
	<=
	assert

	// contracts\AMM.algo.ts:248
	// this.currentFee.value = currentFee
	bytec 7 //  "current_fee"
	frame_dig -1 // currentFee: uint64
	app_global_put
	retsub

// doCreatePoolToken(aAsset: AssetID, bAsset: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// contracts\AMM.algo.ts:252
	// return sendAssetCreation({
	//       configAssetName: 'VLP-' + aAsset.unitName + '-' + bAsset.unitName,
	//       configAssetUnitName: 'vlp',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: 3,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 7 //  acfg
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:253
	// configAssetName: 'VLP-' + aAsset.unitName + '-' + bAsset.unitName
	pushbytes 0x564c502d // "VLP-"
	frame_dig -1 // aAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig -2 // bAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	itxn_field ConfigAssetName

	// contracts\AMM.algo.ts:254
	// configAssetUnitName: 'vlp'
	pushbytes 0x766c70 // "vlp"
	itxn_field ConfigAssetUnitName

	// contracts\AMM.algo.ts:255
	// configAssetTotal: TOTAL_SUPPLY
	intc 4 // 10
	intc 5 // 16
	exp
	itxn_field ConfigAssetTotal

	// contracts\AMM.algo.ts:256
	// configAssetDecimals: 3
	intc 7 // 3
	itxn_field ConfigAssetDecimals

	// contracts\AMM.algo.ts:257
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\AMM.algo.ts:258
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// doAxfer(sender: Address, receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 4 0

	// contracts\AMM.algo.ts:263
	// sendAssetTransfer({
	//       assetCloseTo: sender,
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//     })
	itxn_begin
	intc 3 //  axfer
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:264
	// assetCloseTo: sender
	frame_dig -1 // sender: Address
	itxn_field AssetCloseTo

	// contracts\AMM.algo.ts:265
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// contracts\AMM.algo.ts:266
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts\AMM.algo.ts:267
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID, address: Address): void
doOptIn:
	proto 2 0

	// contracts\AMM.algo.ts:272
	// this.doAxfer(address, address, asset, 0)
	intc 0 // 0
	frame_dig -1 // asset: AssetID
	frame_dig -2 // address: Address
	frame_dig -2 // address: Address
	callsub doAxfer
	retsub

// tokensToMintIntial(aAmount: uint64, bAmount: uint64): uint64
tokensToMintIntial:
	proto 2 1

	// contracts\AMM.algo.ts:276
	// return sqrt(aAmount * bAmount);
	frame_dig -1 // aAmount: uint64
	frame_dig -2 // bAmount: uint64
	*
	sqrt
	retsub

// tokensToMint(issued: uint64, aSupply: uint64, bSupply: uint64, aAmount: uint64, bAmount: uint64): uint64
tokensToMint:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\AMM.algo.ts:280
	// aRatio = wideRatio([aAmount, SCALE], [aSupply])
	frame_dig -4 // aAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -2 // aSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // aRatio: uint64

	// contracts\AMM.algo.ts:281
	// bRatio = wideRatio([bAmount, SCALE], [bSupply])
	frame_dig -5 // bAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -3 // bSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // bRatio: uint64

	// contracts\AMM.algo.ts:283
	// ratio = aRatio < bRatio ? aRatio : bRatio
	frame_dig 0 // aRatio: uint64
	frame_dig 1 // bRatio: uint64
	<
	bz *ternary2_false
	frame_dig 0 // aRatio: uint64
	b *ternary2_end

*ternary2_false:
	frame_dig 1 // bRatio: uint64

*ternary2_end:
	frame_bury 2 // ratio: uint64

	// contracts\AMM.algo.ts:285
	// return wideRatio([ratio, issued], [SCALE]);
	frame_dig 2 // ratio: uint64
	frame_dig -1 // issued: uint64
	mulw
	intc 0 // 0
	intc 2 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// computeRatio(): uint64
computeRatio:
	proto 0 1

	// contracts\AMM.algo.ts:289
	// return wideRatio(
	//       [this.app.address.assetBalance(this.assetA.value), SCALE],
	//       [this.app.address.assetBalance(this.assetB.value)]
	//     );
	global CurrentApplicationAddress
	bytec 3 //  "asset_a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 2 // 1000
	mulw
	intc 0 // 0
	global CurrentApplicationAddress
	bytec 4 //  "asset_b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToBurn(issued: uint64, supply: uint64, amount: uint64): uint64
tokensToBurn:
	proto 3 1

	// contracts\AMM.algo.ts:296
	// return wideRatio([supply, amount], [issued]);
	frame_dig -2 // supply: uint64
	frame_dig -3 // amount: uint64
	mulw
	intc 0 // 0
	frame_dig -1 // issued: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToSwap(inAmount: uint64, inSupply: uint64, outSupply: uint64): uint64
tokensToSwap:
	proto 3 1

	// contracts\AMM.algo.ts:301
	// return wideRatio([inAmount, factor, outSupply], [inSupply * SCALE + inAmount * factor]);
	frame_dig -1 // inAmount: uint64
	intc 2 // 1000
	mulw
	frame_dig -3 // outSupply: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 0 // 0
	frame_dig -2 // inSupply: uint64
	intc 2 // 1000
	*
	frame_dig -1 // inAmount: uint64
	intc 2 // 1000
	*
	+
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// feeToCollect(amount: uint64): uint64
feeToCollect:
	proto 1 1

	// contracts\AMM.algo.ts:305
	// return wideRatio([amount, this.currentFee.value], [SCALE]);
	frame_dig -1 // amount: uint64
	bytec 7 //  "current_fee"
	app_global_get
	mulw
	intc 0 // 0
	intc 2 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x025691c3 // method "bootstrap(pay,uint64,uint64,uint64)uint64"
	pushbytes 0x10045c79 // method "mint(axfer,axfer,uint64,uint64,uint64)void"
	pushbytes 0x028e37c1 // method "burn(axfer,uint64,uint64,uint64)void"
	pushbytes 0x632aaed8 // method "swap(axfer,uint64,uint64)void"
	pushbytes 0x5180fdac // method "createBidderEscrow(pay)address"
	pushbytes 0xa4dd4c1a // method "bid(uint64,uint64,uint64,uint64,axfer)void"
	pushbytes 0x567679eb // method "setManager(address)void"
	pushbytes 0x3dcb5069 // method "setNewFee(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_bootstrap *abi_route_mint *abi_route_burn *abi_route_swap *abi_route_createBidderEscrow *abi_route_bid *abi_route_setManager *abi_route_setNewFee

	// this contract does not implement the given ABI method for call NoOp
	err