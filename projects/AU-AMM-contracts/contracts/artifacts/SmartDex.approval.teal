#pragma version 10
intcblock 0 1 1000 4 10 16 300_000 3 5 6
bytecblock 0x 0x61737365745f61 0x61737365745f62 0x706f6f6c5f746f6b656e 0x63757272656e745f666565 0x64656661756c745f6d616e61676572 0x706f6f6c5f6d616e61676572 0x6d61785f666565 0x726174696f 0x151f7c75

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 9 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\AMM.algo.ts:33
	// this.default_manager.value = this.txn.sender
	bytec 5 //  "default_manager"
	txn Sender
	app_global_put

	// contracts\AMM.algo.ts:34
	// this.currentFee.value = 5
	bytec 4 //  "current_fee"
	intc 8 // 5
	app_global_put
	retsub

// bootstrap(pay,uint64,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	bytec 9 // 0x151f7c75

	// maxFee: uint64
	txna ApplicationArgs 3
	btoi

	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// seed: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 3 (seed) for bootstrap must be a pay transaction
	assert

	// execute bootstrap(pay,uint64,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	intc 1 // 1
	return

// bootstrap(seed: PayTxn, aAsset: AssetID, bAsset: AssetID, maxFee: uint64): AssetID
bootstrap:
	proto 4 1

	// contracts\AMM.algo.ts:38
	// this.maxFee.value = maxFee
	bytec 7 //  "max_fee"
	frame_dig -4 // maxFee: uint64
	app_global_put

	// contracts\AMM.algo.ts:39
	// verifyAppCallTxn(this.txn, { sender: this.default_manager.value })
	// verify sender
	txn Sender
	bytec 5 //  "default_manager"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.default_manager.value"}
	assert

	// contracts\AMM.algo.ts:43
	// verifyPayTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // seed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"seed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // seed: PayTxn
	gtxns Amount
	intc 6 // 300_000
	>=

	// transaction verification failed: {"txn":"seed","field":"amount","condition":"greaterThanEqualTo","expected":">=300_000"}
	assert

	// contracts\AMM.algo.ts:44
	// assert(aAsset < bAsset)
	frame_dig -2 // aAsset: AssetID
	frame_dig -3 // bAsset: AssetID
	<
	assert

	// contracts\AMM.algo.ts:46
	// this.assetA.value = aAsset
	bytec 1 //  "asset_a"
	frame_dig -2 // aAsset: AssetID
	app_global_put

	// contracts\AMM.algo.ts:47
	// this.assetB.value = bAsset
	bytec 2 //  "asset_b"
	frame_dig -3 // bAsset: AssetID
	app_global_put

	// contracts\AMM.algo.ts:48
	// this.poolToken.value = this.doCreatePoolToken(aAsset, bAsset)
	bytec 3 //  "pool_token"
	frame_dig -3 // bAsset: AssetID
	frame_dig -2 // aAsset: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\AMM.algo.ts:50
	// this.doOptIn(aAsset, this.app.address)
	global CurrentApplicationAddress
	frame_dig -2 // aAsset: AssetID
	callsub doOptIn

	// contracts\AMM.algo.ts:51
	// this.doOptIn(bAsset, this.app.address)
	global CurrentApplicationAddress
	frame_dig -3 // bAsset: AssetID
	callsub doOptIn

	// contracts\AMM.algo.ts:53
	// return this.poolToken.value;
	bytec 3 //  "pool_token"
	app_global_get
	retsub

// mint(axfer,axfer,uint64,uint64,uint64)void
*abi_route_mint:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// bXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (bXfer) for mint must be a axfer transaction
	assert

	// aXfer: axfer
	txn GroupIndex
	pushint 2
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 4 (aXfer) for mint must be a axfer transaction
	assert

	// execute mint(axfer,axfer,uint64,uint64,uint64)void
	callsub mint
	intc 1 // 1
	return

// mint(aXfer: AssetTransferTxn, bXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
mint:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// well formed mint
	// contracts\AMM.algo.ts:83
	// assert(aAsset === this.assetA.value)
	frame_dig -4 // aAsset: AssetID
	bytec 1 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:84
	// assert(bAsset === this.assetB.value)
	frame_dig -5 // bAsset: AssetID
	bytec 2 //  "asset_b"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:85
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: AssetID
	bytec 3 //  "pool_token"
	app_global_get
	==
	assert

	// valid asset A axfer
	// contracts\AMM.algo.ts:88
	// verifyAssetTransferTxn(aXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: aAsset,
	//     })
	// verify sender
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"aXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"aXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"aXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // aAsset: AssetID
	==

	// transaction verification failed: {"txn":"aXfer","field":"xferAsset","expected":"aAsset"}
	assert

	// valid asset B axfer
	// contracts\AMM.algo.ts:96
	// verifyAssetTransferTxn(bXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: bAsset,
	//     })
	// verify sender
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"bXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"bXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"bXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // bAsset: AssetID
	==

	// transaction verification failed: {"txn":"bXfer","field":"xferAsset","expected":"bAsset"}
	assert

	// *if0_condition
	// contracts\AMM.algo.ts:104
	// this.app.address.assetBalance(aAsset) === aXfer.assetAmount &&
	//       this.app.address.assetBalance(bAsset) === bXfer.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if0_else

	// *if0_consequent
	// contracts\AMM.algo.ts:107
	// this.tokensToMintIntial(aXfer.assetAmount, bXfer.assetAmount)
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToMintIntial
	b *if0_end

*if0_else:
	// contracts\AMM.algo.ts:109
	// toMint = this.tokensToMint(
	//         TOTAL_SUPPLY - this.app.address.assetBalance(poolAsset),
	//         this.app.address.assetBalance(aAsset) - aXfer.assetAmount,
	//         this.app.address.assetBalance(bAsset) - bXfer.assetAmount,
	//         aXfer.assetAmount,
	//         bXfer.assetAmount
	//       )
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	intc 4 // 10
	intc 5 // 16
	exp
	global CurrentApplicationAddress
	frame_dig -3 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	-
	callsub tokensToMint
	frame_bury 0 // toMint: uint64

	// contracts\AMM.algo.ts:117
	// assert(toMint > 0)
	frame_dig 0 // toMint: uint64
	intc 0 // 0
	>
	assert

	// contracts\AMM.algo.ts:119
	// this.doAxfer(this.app.address, this.txn.sender, poolAsset, toMint)
	frame_dig 0 // toMint: uint64
	frame_dig -3 // poolAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

*if0_end:
	retsub

// burn(axfer,uint64,uint64,uint64)void
*abi_route_burn:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// poolXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (poolXfer) for burn must be a axfer transaction
	assert

	// execute burn(axfer,uint64,uint64,uint64)void
	callsub burn
	intc 1 // 1
	return

// burn(poolXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
burn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// well formed burn
	// contracts\AMM.algo.ts:125
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: AssetID
	bytec 3 //  "pool_token"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:126
	// assert(aAsset === this.assetA.value)
	frame_dig -3 // aAsset: AssetID
	bytec 1 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:127
	// assert(bAsset === this.assetB.value)
	frame_dig -4 // bAsset: AssetID
	bytec 2 //  "asset_b"
	app_global_get
	==
	assert

	// valid pool axfer
	// contracts\AMM.algo.ts:130
	// verifyAssetTransferTxn(poolXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//     })
	// verify sender
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"poolXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"poolXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"poolXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: AssetID
	==

	// transaction verification failed: {"txn":"poolXfer","field":"xferAsset","expected":"poolAsset"}
	assert

	// contracts\AMM.algo.ts:137
	// issued = TOTAL_SUPPLY - (this.app.address.assetBalance(poolAsset) - poolXfer.assetAmount)
	intc 4 // 10
	intc 5 // 16
	exp
	global CurrentApplicationAddress
	frame_dig -2 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	-
	frame_bury 0 // issued: uint64

	// contracts\AMM.algo.ts:139
	// aAmt = this.tokensToBurn(issued, this.app.address.assetBalance(aAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -3 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 1 // aAmt: uint64

	// contracts\AMM.algo.ts:141
	// bAmt = this.tokensToBurn(issued, this.app.address.assetBalance(bAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -4 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 2 // bAmt: uint64

	// contracts\AMM.algo.ts:143
	// this.doAxfer(this.app.address, this.txn.sender, aAsset, aAmt)
	frame_dig 1 // aAmt: uint64
	frame_dig -3 // aAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:144
	// this.doAxfer(this.app.address, this.txn.sender, bAsset, bAmt)
	frame_dig 2 // bAmt: uint64
	frame_dig -4 // bAsset: AssetID
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:146
	// this.ratio.value = this.computeRatio()
	bytec 8 //  "ratio"
	callsub computeRatio
	app_global_put
	retsub

// swap(axfer,uint64,uint64)void
*abi_route_swap:
	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// swapXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 2 (swapXfer) for swap must be a axfer transaction
	assert

	// execute swap(axfer,uint64,uint64)void
	callsub swap
	intc 1 // 1
	return

// swap(swapXfer: AssetTransferTxn, aAsset: AssetID, bAsset: AssetID): void
swap:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// well formed swap
	// contracts\AMM.algo.ts:151
	// assert(aAsset === this.assetA.value)
	frame_dig -2 // aAsset: AssetID
	bytec 1 //  "asset_a"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:152
	// assert(bAsset === this.assetB.value)
	frame_dig -3 // bAsset: AssetID
	bytec 2 //  "asset_b"
	app_global_get
	==
	assert

	// contracts\AMM.algo.ts:154
	// verifyAssetTransferTxn(swapXfer, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [aAsset, bAsset] },
	//     })
	// verify assetAmount
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"swapXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"swapXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"swapXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // bAsset: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"swapXfer"},"field":"xferAsset","condition":"includedIn","expected":"[aAsset, bAsset]"}
	assert

	// contracts\AMM.algo.ts:161
	// outId = swapXfer.xferAsset === aAsset ? aAsset : bAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	bz *ternary0_false
	frame_dig -2 // aAsset: AssetID
	b *ternary0_end

*ternary0_false:
	frame_dig -3 // bAsset: AssetID

*ternary0_end:
	frame_bury 0 // outId: uint64

	// contracts\AMM.algo.ts:163
	// inId = swapXfer.xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_bury 1 // inId: uint64

	// contracts\AMM.algo.ts:165
	// fees = this.feeToCollect(swapXfer.assetAmount)
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub feeToCollect
	frame_bury 2 // fees: uint64

	// contracts\AMM.algo.ts:167
	// toSwap = this.tokensToSwap(
	//       swapXfer.assetAmount - fees,
	//       this.app.address.assetBalance(inId) - swapXfer.assetAmount,
	//       this.app.address.assetBalance(outId)
	//     )
	global CurrentApplicationAddress
	frame_dig 0 // outId: uint64
	asset_holding_get AssetBalance
	pop
	global CurrentApplicationAddress
	frame_dig 1 // inId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 2 // fees: uint64
	-
	callsub tokensToSwap
	frame_bury 3 // toSwap: uint64

	// contracts\AMM.algo.ts:173
	// assert(toSwap > 0)
	frame_dig 3 // toSwap: uint64
	intc 0 // 0
	>
	assert

	// contracts\AMM.algo.ts:175
	// this.doAxfer(this.app.address, this.txn.sender, outId, toSwap)
	frame_dig 3 // toSwap: uint64
	frame_dig 0 // outId: uint64
	txn Sender
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:177
	// this.doAxfer(this.app.address, this.poolManager.value, inId, fees)
	frame_dig 2 // fees: uint64
	frame_dig 1 // inId: uint64
	bytec 6 //  "pool_manager"
	app_global_get
	global CurrentApplicationAddress
	callsub doAxfer

	// contracts\AMM.algo.ts:179
	// this.ratio.value = this.computeRatio()
	bytec 8 //  "ratio"
	callsub computeRatio
	app_global_put
	retsub

// createBidderEscrow(pay)address
*abi_route_createBidderEscrow:
	// The ABI return prefix
	bytec 9 // 0x151f7c75

	// payMBR: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (payMBR) for createBidderEscrow must be a pay transaction
	assert

	// execute createBidderEscrow(pay)address
	callsub createBidderEscrow
	concat
	log
	intc 1 // 1
	return

// createBidderEscrow(payMBR: PayTxn): Address
createBidderEscrow:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\AMM.algo.ts:183
	// verifyPayTxn(payMBR, {
	//       receiver: this.app.address,
	//       amount: { greaterThan: 400_000 },
	//     })
	// verify receiver
	frame_dig -1 // payMBR: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payMBR","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payMBR: PayTxn
	gtxns Amount
	pushint 400_000
	>

	// transaction verification failed: {"txn":"payMBR","field":"amount","condition":"greaterThan","expected":">400_000"}
	assert

	// contracts\AMM.algo.ts:188
	// bidderPuppetAccount = sendMethodCall<typeof PuppetAddress.prototype.new>({
	//       onCompletion: OnCompletion.DeleteApplication,
	//       approvalProgram: PuppetAddress.approvalProgram(),
	//       clearStateProgram: PuppetAddress.clearProgram(),
	//     })
	itxn_begin
	intc 9 //  appl
	itxn_field TypeEnum
	pushbytes 0x561d2fea // method "new()address"
	itxn_field ApplicationArgs

	// contracts\AMM.algo.ts:189
	// onCompletion: OnCompletion.DeleteApplication
	intc 8 //  DeleteApplication
	itxn_field OnCompletion

	// contracts\AMM.algo.ts:190
	// approvalProgram: PuppetAddress.approvalProgram()
	pushbytes 0x0a2002000131181481060b3119088d0c000000000000000000000000000000000000000000000027008004151f7c7588000450b023438a0001b123b210320ab20722b208320eb22022b201b3320a898004561d2fea361a008e01ffcd00
	itxn_field ApprovalProgram

	// contracts\AMM.algo.ts:191
	// clearStateProgram: PuppetAddress.clearProgram()
	pushbytes 0x0a
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // bidderPuppetAccount: address

	// contracts\AMM.algo.ts:194
	// sendPayment({
	//       receiver: bidderPuppetAccount,
	//       amount: 300_000,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:195
	// receiver: bidderPuppetAccount
	frame_dig 0 // bidderPuppetAccount: address
	itxn_field Receiver

	// contracts\AMM.algo.ts:196
	// amount: 300_000
	intc 6 // 300_000
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\AMM.algo.ts:199
	// this.doOptIn(this.poolToken.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 3 //  "pool_token"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:200
	// this.doOptIn(this.assetA.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 1 //  "asset_a"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:201
	// this.doOptIn(this.assetB.value, bidderPuppetAccount)
	frame_dig 0 // bidderPuppetAccount: address
	bytec 2 //  "asset_b"
	app_global_get
	callsub doOptIn

	// contracts\AMM.algo.ts:203
	// this.biddersRegistry(this.txn.sender).value = bidderPuppetAccount
	pushbytes 0x626964646572735f7265676973747279 // "bidders_registry"
	txn Sender
	concat
	frame_dig 0 // bidderPuppetAccount: address
	box_put

	// contracts\AMM.algo.ts:205
	// return bidderPuppetAccount;
	frame_dig 0 // bidderPuppetAccount: address

	// set the subroutine return value
	frame_bury 0
	retsub

// setNewFee(uint64)void
*abi_route_setNewFee:
	// currentFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute setNewFee(uint64)void
	callsub setNewFee
	intc 1 // 1
	return

// setNewFee(currentFee: uint64): void
setNewFee:
	proto 1 0

	// contracts\AMM.algo.ts:214
	// verifyTxn(this.txn, {
	//       sender: this.poolManager.value,
	//     })
	// verify sender
	txn Sender
	bytec 6 //  "pool_manager"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.poolManager.value"}
	assert

	// contracts\AMM.algo.ts:217
	// assert(currentFee <= this.maxFee.value)
	frame_dig -1 // currentFee: uint64
	bytec 7 //  "max_fee"
	app_global_get
	<=
	assert

	// contracts\AMM.algo.ts:218
	// this.currentFee.value = currentFee
	bytec 4 //  "current_fee"
	frame_dig -1 // currentFee: uint64
	app_global_put
	retsub

// doCreatePoolToken(aAsset: AssetID, bAsset: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// contracts\AMM.algo.ts:222
	// return sendAssetCreation({
	//       configAssetName: 'VLP-' + aAsset.unitName + '-' + bAsset.unitName,
	//       configAssetUnitName: 'vlp',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: 3,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 7 //  acfg
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:223
	// configAssetName: 'VLP-' + aAsset.unitName + '-' + bAsset.unitName
	pushbytes 0x564c502d // "VLP-"
	frame_dig -1 // aAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig -2 // bAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	itxn_field ConfigAssetName

	// contracts\AMM.algo.ts:224
	// configAssetUnitName: 'vlp'
	pushbytes 0x766c70 // "vlp"
	itxn_field ConfigAssetUnitName

	// contracts\AMM.algo.ts:225
	// configAssetTotal: TOTAL_SUPPLY
	intc 4 // 10
	intc 5 // 16
	exp
	itxn_field ConfigAssetTotal

	// contracts\AMM.algo.ts:226
	// configAssetDecimals: 3
	intc 7 // 3
	itxn_field ConfigAssetDecimals

	// contracts\AMM.algo.ts:227
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\AMM.algo.ts:228
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// doAxfer(sender: Address, receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 4 0

	// contracts\AMM.algo.ts:233
	// sendAssetTransfer({
	//       assetCloseTo: sender,
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//     })
	itxn_begin
	intc 3 //  axfer
	itxn_field TypeEnum

	// contracts\AMM.algo.ts:234
	// assetCloseTo: sender
	frame_dig -1 // sender: Address
	itxn_field AssetCloseTo

	// contracts\AMM.algo.ts:235
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// contracts\AMM.algo.ts:236
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts\AMM.algo.ts:237
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID, address: Address): void
doOptIn:
	proto 2 0

	// contracts\AMM.algo.ts:242
	// this.doAxfer(address, address, asset, 0)
	intc 0 // 0
	frame_dig -1 // asset: AssetID
	frame_dig -2 // address: Address
	frame_dig -2 // address: Address
	callsub doAxfer
	retsub

// tokensToMintIntial(aAmount: uint64, bAmount: uint64): uint64
tokensToMintIntial:
	proto 2 1

	// contracts\AMM.algo.ts:246
	// return sqrt(aAmount * bAmount);
	frame_dig -1 // aAmount: uint64
	frame_dig -2 // bAmount: uint64
	*
	sqrt
	retsub

// tokensToMint(issued: uint64, aSupply: uint64, bSupply: uint64, aAmount: uint64, bAmount: uint64): uint64
tokensToMint:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\AMM.algo.ts:250
	// aRatio = wideRatio([aAmount, SCALE], [aSupply])
	frame_dig -4 // aAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -2 // aSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // aRatio: uint64

	// contracts\AMM.algo.ts:251
	// bRatio = wideRatio([bAmount, SCALE], [bSupply])
	frame_dig -5 // bAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -3 // bSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // bRatio: uint64

	// contracts\AMM.algo.ts:253
	// ratio = aRatio < bRatio ? aRatio : bRatio
	frame_dig 0 // aRatio: uint64
	frame_dig 1 // bRatio: uint64
	<
	bz *ternary1_false
	frame_dig 0 // aRatio: uint64
	b *ternary1_end

*ternary1_false:
	frame_dig 1 // bRatio: uint64

*ternary1_end:
	frame_bury 2 // ratio: uint64

	// contracts\AMM.algo.ts:255
	// return wideRatio([ratio, issued], [SCALE]);
	frame_dig 2 // ratio: uint64
	frame_dig -1 // issued: uint64
	mulw
	intc 0 // 0
	intc 2 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// computeRatio(): uint64
computeRatio:
	proto 0 1

	// contracts\AMM.algo.ts:259
	// return wideRatio(
	//       [this.app.address.assetBalance(this.assetA.value), SCALE],
	//       [this.app.address.assetBalance(this.assetB.value)]
	//     );
	global CurrentApplicationAddress
	bytec 1 //  "asset_a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 2 // 1000
	mulw
	intc 0 // 0
	global CurrentApplicationAddress
	bytec 2 //  "asset_b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToBurn(issued: uint64, supply: uint64, amount: uint64): uint64
tokensToBurn:
	proto 3 1

	// contracts\AMM.algo.ts:266
	// return wideRatio([supply, amount], [issued]);
	frame_dig -2 // supply: uint64
	frame_dig -3 // amount: uint64
	mulw
	intc 0 // 0
	frame_dig -1 // issued: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToSwap(inAmount: uint64, inSupply: uint64, outSupply: uint64): uint64
tokensToSwap:
	proto 3 1

	// contracts\AMM.algo.ts:271
	// return wideRatio([inAmount, factor, outSupply], [inSupply * SCALE + inAmount * factor]);
	frame_dig -1 // inAmount: uint64
	intc 2 // 1000
	mulw
	frame_dig -3 // outSupply: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 0 // 0
	frame_dig -2 // inSupply: uint64
	intc 2 // 1000
	*
	frame_dig -1 // inAmount: uint64
	intc 2 // 1000
	*
	+
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// feeToCollect(amount: uint64): uint64
feeToCollect:
	proto 1 1

	// contracts\AMM.algo.ts:275
	// return wideRatio([amount, this.currentFee.value], [SCALE]);
	frame_dig -1 // amount: uint64
	bytec 4 //  "current_fee"
	app_global_get
	mulw
	intc 0 // 0
	intc 2 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x025691c3 // method "bootstrap(pay,uint64,uint64,uint64)uint64"
	pushbytes 0x10045c79 // method "mint(axfer,axfer,uint64,uint64,uint64)void"
	pushbytes 0x028e37c1 // method "burn(axfer,uint64,uint64,uint64)void"
	pushbytes 0x632aaed8 // method "swap(axfer,uint64,uint64)void"
	pushbytes 0x5180fdac // method "createBidderEscrow(pay)address"
	pushbytes 0x3dcb5069 // method "setNewFee(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_bootstrap *abi_route_mint *abi_route_burn *abi_route_swap *abi_route_createBidderEscrow *abi_route_setNewFee

	// this contract does not implement the given ABI method for call NoOp
	err